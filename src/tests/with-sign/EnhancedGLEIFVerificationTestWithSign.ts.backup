import * as dotenv from 'dotenv';
dotenv.config();

import { Field, Mina, PrivateKey, AccountUpdate, CircuitString, Poseidon, Signature, UInt64, Bool } from 'o1js';
import { isCacheValid, saveBlockchainState, loadBlockchainState, saveDeployedContracts, loadDeployedContracts, saveCacheMetadata } from '../../scripts/blockchain-cache.js';

// Import the PRECOMPILED Enhanced modules directly
import { 
    GLEIFEnhancedZKProgram, 
    GLEIFEnhancedComplianceData 
} from '../../zk-programs/with-sign/GLEIFEnhancedZKProgramWithSign.js';

import { 
    GLEIFEnhancedVerifierSmartContractWithSign 
} from '../../contracts/with-sign/GLEIFEnhancedVerifierSmartContractWithSign.js';

import { 
    GLEIFdeployerAccount, 
    GLEIFsenderAccount, 
    GLEIFdeployerKey, 
    GLEIFsenderKey, 
    getPrivateKeyFor 
} from '../../core/OracleRegistry.js';

import { fetchGLEIFCompanyData } from './GLEIFUtils.js';

/**
 * Enhanced GLEIF Verification Test - PRECOMPILED VERSION
 * 
 * This test uses precompiled Enhanced GLEIF modules and follows the same 
 * simple pattern as the regular GLEIFVerificationTestWithSign.js
 */

async function main() {
    console.log('ðŸŒŸ Enhanced GLEIF Verification Test (PRECOMPILED VERSION)');
    console.log('======================================================');
    console.log('ðŸ”§ Using precompiled Enhanced GLEIF modules...');
    console.log('');
    
    // Get command line arguments
    const companyName = process.argv[2];
    let typeOfNet = process.argv[3] || 'LOCAL'; // Default to LOCAL like other working tests
    let testMode = process.argv[4] || 'STANDARD'; // STANDARD, FAST, or PRECOMPILED
    
    // Check for precompiled toggle from environment variable or command line
    const usePrecompiled = process.env.USE_PRECOMPILED === 'true' || 
                          testMode.toUpperCase() === 'PRECOMPILED' || 
                          testMode.toUpperCase() === 'FAST';
    
    if (!companyName) {
        console.log('Usage: node EnhancedGLEIFVerificationTestWithSign.js <company_name> [network_type] [test_mode]');
        console.log('');
        console.log('Examples:');
        console.log('  node EnhancedGLEIFVerificationTestWithSign.js "zenova_gleif" LOCAL');
        console.log('  node EnhancedGLEIFVerificationTestWithSign.js "SREE PALANI ANDAVAR AGROS PRIVATE LIMITED" TESTNET');
        console.log('  node EnhancedGLEIFVerificationTestWithSign.js "SREE PALANI ANDAVAR AGROS PRIVATE LIMITED" TESTNET PRECOMPILED');
        console.log('  node EnhancedGLEIFVerificationTestWithSign.js "SREE PALANI ANDAVAR AGROS PRIVATE LIMITED" TESTNET FAST');
        console.log('');
        console.log('Network Types: LOCAL, TESTNET, MAINNET');
        console.log('Test Modes:');
        console.log('  STANDARD     - Full compilation and proof generation (slower, complete)');
        console.log('  FAST         - Skip ZK proof generation entirely (fastest, smart contract only)');
        console.log('  PRECOMPILED  - Try cached provers first, fallback to compilation (balanced)');
        console.log('');
        console.log('Environment Variables:');
        console.log('  USE_PRECOMPILED=true  - Enable precompiled mode globally');
        process.exit(1);
    }
    
    console.log('ðŸ“‹ Configuration:');
    console.log(`   ðŸ¢ Company Name: ${companyName}`);
    console.log(`   ðŸŒ Network Type: ${typeOfNet}`);
    console.log(`   âš™ï¸ Test Mode: ${testMode.toUpperCase()}`);
    console.log(`   ðŸš€ Use Precompiled: ${usePrecompiled ? 'YES' : 'NO'}`);
    console.log('');
    
    try {
        // Run the enhanced GLEIF verification
        let proof = await runEnhancedGLEIFVerificationPrecompiled(companyName, typeOfNet, usePrecompiled);
        
        console.log('\nðŸŽ‰ Enhanced GLEIF Verification Completed Successfully!');
        console.log('âœ… Enhanced compliance verification passed');
        console.log('ðŸ” Oracle signature verified');
        console.log(`ðŸ§® ZK proof ${proof.technicalDetails?.verified ? 'generated and verified' : 'generation attempted'}`);
        console.log('ðŸ“ Smart contract state updated');
        console.log('ðŸ“Š All blockchain state transitions logged');
        console.log('ðŸ” Complete verification audit trail available');
        
        if (usePrecompiled && !proof.technicalDetails?.verified) {
            console.log('\nðŸ’¡ Tip: For full ZK proof generation, use STANDARD mode:');
            console.log(`   node ${process.argv[1]} "${companyName}" ${typeOfNet} STANDARD`);
        }
        
    } catch (error: any) {
        console.error('\nâŒ Enhanced GLEIF Verification Failed:');
        console.error('Error:', error.message);
        if (error.stack) {
            console.error('Stack:', error.stack);
        }
        process.exit(1);
    }
}

/**
 * Helper function to setup blockchain with caching
 */
async function setupBlockchainWithCaching() {
    console.log('ðŸ”‘ Setting up Enhanced ZKApp with Smart Caching...');
    
    // Check if we can use cached blockchain state
    const useCachedBlockchain = isCacheValid() && !process.env.FORCE_FRESH_BLOCKCHAIN;
    
    if (useCachedBlockchain) {
        console.log('ðŸš€ Loading cached blockchain state...');
        
        try {
            const cachedState = loadBlockchainState();
            const cachedContracts = loadDeployedContracts();
            
            if (cachedState && cachedContracts) {
                console.log('âœ… Found valid cached blockchain state');
                console.log(`   ðŸ“ Cached blockchain height: ${cachedState.blockchainHeight}`);
                console.log(`   ðŸ’° Cached deployer balance: ${cachedState.deployerBalance} MINA`);
                console.log(`   ðŸ’° Cached sender balance: ${cachedState.senderBalance} MINA`);
                console.log(`   ðŸ›ï¸ Cached zkApp address: ${cachedContracts.zkAppAddress}`);
                
                // Restore blockchain state
                const Local = await Mina.LocalBlockchain({ proofsEnabled: false });
                Mina.setActiveInstance(Local);
                
                const deployerAccount = Local.testAccounts[0];
                const deployerKey = deployerAccount.key;
                const senderAccount = Local.testAccounts[1];
                const senderKey = senderAccount.key;
                
                // Restore deployed contract
                const zkAppKey = PrivateKey.fromBase58(cachedContracts.zkAppPrivateKey);
                const zkAppAddress = zkAppKey.toPublicKey();
                const zkApp = new GLEIFEnhancedVerifierSmartContractWithSign(zkAppAddress);
                
                console.log('âœ… Blockchain state restored from cache!');
                console.log('ðŸš€ Skipping deployment - using cached smart contract');
                
                return { 
                    deployerAccount, deployerKey, senderAccount, senderKey, 
                    zkAppKey, zkAppAddress, zkApp, 
                    fromCache: true 
                };
            }
        } catch (error) {
            console.log('âš ï¸ Failed to load cached state, proceeding with fresh setup');
        }
    }
    
    // Fresh blockchain setup
    console.log('ðŸ”„ Setting up fresh local blockchain...');
    const useProof = false; // Disable proofs for faster testing
    const Local = await Mina.LocalBlockchain({ proofsEnabled: useProof });
    Mina.setActiveInstance(Local);
    
    const deployerAccount = Local.testAccounts[0];
    const deployerKey = deployerAccount.key;
    const senderAccount = Local.testAccounts[1];
    const senderKey = senderAccount.key;
    
    const zkAppKey = PrivateKey.random();
    const zkAppAddress = zkAppKey.toPublicKey();
    const zkApp = new GLEIFEnhancedVerifierSmartContractWithSign(zkAppAddress);
    
    return { 
        deployerAccount, deployerKey, senderAccount, senderKey, 
        zkAppKey, zkAppAddress, zkApp, 
        fromCache: false 
    };
}
async function runEnhancedGLEIFVerificationPrecompiled(companyName: string, typeOfNet: string, usePrecompiled: boolean = true) {
    console.log('\nðŸŒŸ ENHANCED GLEIF VERIFICATION WITH BUSINESS RULES');
    console.log('='.repeat(70));
    console.log('ðŸ“‹ ENHANCED BUSINESS RULES:');
    console.log('1. ðŸ‘¤ Entity Status = "ACTIVE"');
    console.log('2. ðŸ“… Current Date Within Valid Period');
    console.log('3. ðŸ“‹ Registration Status = "ISSUED"');
    console.log('4. ðŸ”– Conformity Flag â‰  "NON_CONFORMING"');
    console.log('='.repeat(70));
    
    // DON'T COMPILE during setup - Use precompiled versions directly for speed
    console.log('ðŸ”§ Using precompiled Enhanced ZK Program...');
    console.log('ðŸ”§ Using precompiled Enhanced Smart Contract...');
    
    // Note: ZK Program will be compiled later if proof generation is needed
    
    // =================================== ZKApp Setup with Caching ===================================
    console.log('ðŸ”‘ Setting up Enhanced ZKApp with Smart Caching...');
    
    // Check if we can use cached blockchain state
    const useCachedBlockchain = isCacheValid() && !process.env.FORCE_FRESH_BLOCKCHAIN;
    
    if (useCachedBlockchain) {
        console.log('ðŸš€ Loading cached blockchain state...');
        
        try {
            const cachedState = loadBlockchainState();
            const cachedContracts = loadDeployedContracts();
            
            if (cachedState && cachedContracts) {
                console.log('âœ… Found valid cached blockchain state');
                console.log(`   ðŸ“ Cached blockchain height: ${cachedState.blockchainHeight}`);
                console.log(`   ðŸ’° Cached deployer balance: ${cachedState.deployerBalance} MINA`);
                console.log(`   ðŸ’° Cached sender balance: ${cachedState.senderBalance} MINA`);
                console.log(`   ðŸ›ï¸ Cached zkApp address: ${cachedContracts.zkAppAddress}`);
                
                // Restore blockchain state
                const Local = await Mina.LocalBlockchain({ proofsEnabled: false });
                Mina.setActiveInstance(Local);
                
                const deployerAccount = Local.testAccounts[0];
                const deployerKey = deployerAccount.key;
                const senderAccount = Local.testAccounts[1];
                const senderKey = senderAccount.key;
                
                // Restore deployed contract
                const zkAppKey = PrivateKey.fromBase58(cachedContracts.zkAppPrivateKey);
                const zkAppAddress = zkAppKey.toPublicKey();
                const zkApp = new GLEIFEnhancedVerifierSmartContractWithSign(zkAppAddress);
                
                console.log('âœ… Blockchain state restored from cache!');
                console.log('ðŸš€ Skipping deployment - using cached smart contract');
                
                // Skip to the main verification logic
                return { 
                    deployerAccount, deployerKey, senderAccount, senderKey, 
                    zkAppKey, zkAppAddress, zkApp, 
                    fromCache: true 
                };
            }
        } catch (error) {
            console.log('âš ï¸ Failed to load cached state, proceeding with fresh setup');
        }
    }
    
    // Fresh blockchain setup
    console.log('ðŸ”„ Setting up fresh local blockchain...');
    const useProof = false; // Disable proofs for faster testing
    const Local = await Mina.LocalBlockchain({ proofsEnabled: useProof });
    Mina.setActiveInstance(Local);
    
    const deployerAccount = Local.testAccounts[0];
    const deployerKey = deployerAccount.key;
    const senderAccount = Local.testAccounts[1];
    const senderKey = senderAccount.key;
    
    const zkAppKey = PrivateKey.random();
    const zkAppAddress = zkAppKey.toPublicKey();
    const zkApp = new GLEIFEnhancedVerifierSmartContractWithSign(zkAppAddress);
    
    return { 
        deployerAccount, deployerKey, senderAccount, senderKey, 
        zkAppKey, zkAppAddress, zkApp, 
        fromCache: false 
    };

    // =================================== Deployment ===================================
    console.log('ðŸš€ Deploying Enhanced GLEIF ZKApp...');
    
    // BEFORE DEPLOYMENT STATE
    console.log('\nðŸ“Š BEFORE DEPLOYMENT:');
    console.log('ðŸŒ Blockchain State:');
    const beforeDeployBlockchainHeight = Mina.getNetworkState().blockchainLength;
    console.log(`   ðŸ“ Blockchain Height: ${beforeDeployBlockchainHeight.toString()}`);
    console.log(`   ðŸ’° Deployer Balance: ${Mina.getBalance(deployerAccount).toString()} MINA`);
    console.log(`   ðŸ’° Sender Balance: ${Mina.getBalance(senderAccount).toString()} MINA`);
    
    const deployTxn = await Mina.transaction(
        deployerAccount,
        async () => {
            AccountUpdate.fundNewAccount(deployerAccount);
            await zkApp.deploy();
        }
    );
    await deployTxn.sign([deployerKey, zkAppKey]).send();
    
    // AFTER DEPLOYMENT STATE
    console.log('\nðŸ“Š AFTER DEPLOYMENT:');
    console.log('ðŸŒ Blockchain State:');
    const afterDeployBlockchainHeight = Mina.getNetworkState().blockchainLength;
    console.log(`   ðŸ“ Blockchain Height: ${afterDeployBlockchainHeight.toString()}`);
    console.log(`   ðŸ’° Deployer Balance: ${Mina.getBalance(deployerAccount).toString()} MINA`);
    console.log(`   ðŸ’° Sender Balance: ${Mina.getBalance(senderAccount).toString()} MINA`);
    console.log(`   ðŸ’° zkApp Balance: ${Mina.getBalance(zkAppAddress).toString()} MINA`);
    
    console.log('\nðŸ“ˆ Deployment Changes:');
    console.log(`   ðŸ“ Blockchain Height: ${beforeDeployBlockchainHeight.toString()} â†’ ${afterDeployBlockchainHeight.toString()}`);
    console.log("âœ… Enhanced GLEIF ZKApp deployed successfully");

    // =================================== Data Fetching ===================================
    console.log('\nðŸ“¡ Fetching GLEIF API Data...');
    
    let parsedData: any;
    try {
        parsedData = await fetchGLEIFCompanyData(companyName, typeOfNet);
        console.log('âœ… GLEIF data fetched successfully');
    } catch (err: any) {
        console.error('âŒ Error fetching company data:', err.message);
        throw err;
    }

    // =================================== Enhanced Compliance Data Creation ===================================
    console.log('\nðŸ”„ Creating enhanced compliance data...');
    
    // Validate business rules (simplified for precompiled version)
    const entity = parsedData.data[0].attributes.entity;
    const registration = parsedData.data[0].attributes.registration;
    
    const isEntityActive = entity.status === 'ACTIVE';
    const isRegistrationIssued = registration.status === 'ISSUED';
    const isConformityValid = registration.conformityFlag !== 'NON_CONFORMING';
    
    // Calculate compliance score based on business rules
    const complianceScore = isEntityActive && isRegistrationIssued && isConformityValid ? 95 : 45;
    const riskLevel = isEntityActive && isRegistrationIssued ? 1 : 5;
    
    console.log('ðŸ“Š Business Rules Validation:');
    console.log(`   ðŸ‘¤ Entity Status: ${entity.status} ${isEntityActive ? 'âœ…' : 'âŒ'}`);
    console.log(`   ðŸ“‹ Registration Status: ${registration.status} ${isRegistrationIssued ? 'âœ…' : 'âŒ'}`);
    console.log(`   ðŸ”– Conformity Flag: ${registration.conformityFlag || 'UNKNOWN'} ${isConformityValid ? 'âœ…' : 'âŒ'}`);
    console.log(`   ðŸ“Š Compliance Score: ${complianceScore}`);
    console.log(`   âš¡ Risk Level: ${riskLevel}`);
    
    // Create enhanced compliance data using precompiled class
    const enhancedData = new GLEIFEnhancedComplianceData({
        type: CircuitString.fromString(parsedData.data[0].type || 'lei-records'),
        id: CircuitString.fromString(parsedData.data[0].id || ''),
        lei: CircuitString.fromString(parsedData.data[0].attributes.lei || ''),
        name: CircuitString.fromString(entity.legalName?.name || ''),
        
        // Set status based on business rules validation
        registration_status: CircuitString.fromString(isRegistrationIssued ? 'ISSUED' : registration.status || 'INACTIVE'),
        entity_status: CircuitString.fromString(isEntityActive ? 'ACTIVE' : entity.status || 'INACTIVE'),
        validation_status: CircuitString.fromString('VALIDATED'),
        
        jurisdiction: CircuitString.fromString(entity.jurisdiction || 'UNKNOWN'),
        legalForm_id: CircuitString.fromString(entity.legalForm?.id || 'UNKNOWN'),
        registeredAt_id: CircuitString.fromString('GLEIF'),
        
        initialRegistrationDate: CircuitString.fromString(registration.initialRegistrationDate || ''),
        lastUpdateDate: CircuitString.fromString(registration.lastUpdateDate || ''),
        nextRenewalDate: CircuitString.fromString(registration.nextRenewalDate || ''),
        
        legalAddress_country: CircuitString.fromString(entity.legalAddress?.country || 'UNKNOWN'),
        legalAddress_city: CircuitString.fromString(entity.legalAddress?.city || 'UNKNOWN'),
        headquartersAddress_country: CircuitString.fromString(entity.headquartersAddress?.country || 'UNKNOWN'),
        
        managingLou: CircuitString.fromString(registration.managingLou || 'UNKNOWN'),
        corroborationLevel: CircuitString.fromString(registration.corroborationLevel || 'UNKNOWN'),
        conformityFlag: CircuitString.fromString(registration.conformityFlag || 'UNKNOWN'),
        
        companyGroup: Field(0), // Default to no group
        parentLEI: CircuitString.fromString(''),
        subsidiaryCount: Field(0),
        
        complianceScore: Field(complianceScore),
        riskLevel: Field(riskLevel),
        lastVerificationTimestamp: UInt64.from(Date.now()),
    });

    // =================================== Oracle Signature Generation ===================================
    console.log('ðŸ” Generating oracle signatures...');
    
    const registryPrivateKey = getPrivateKeyFor('GLEIF');
    const complianceDataHash = Poseidon.hash(GLEIFEnhancedComplianceData.toFields(enhancedData));
    const oracleSignature = Signature.create(registryPrivateKey, [complianceDataHash]);
    
    console.log('âœ… Oracle signature generated successfully');
    
    // DETAILED ORACLE SIGNATURE INFORMATION
    console.log('\nðŸ” DETAILED ORACLE SIGNATURE INFORMATION:');
    console.log('ðŸ“œ Oracle Details:');
    console.log(`   ðŸ”‘ Registry: GLEIF`);
    console.log(`   ðŸ“œ Data Hash: ${complianceDataHash.toString()}`);
    console.log(`   âœï¸ Signature R: ${oracleSignature.r.toString()}`);
    console.log(`   âœï¸ Signature S: ${oracleSignature.s.toString()}`);
    console.log(`   ðŸ—º Signature Type: Poseidon Hash + Ed25519`);

    // =================================== Smart Contract Verification ===================================
    console.log('\nðŸ” Verifying compliance on enhanced smart contract...');
    
    // BEFORE VERIFICATION STATE
    console.log('\nðŸ“Š BEFORE SMART CONTRACT VERIFICATION:');
    console.log('ðŸŒ Blockchain State:');
    const beforeVerifyBlockchainHeight = Mina.getNetworkState().blockchainLength;
    console.log(`   ðŸ“ Blockchain Height: ${beforeVerifyBlockchainHeight.toString()}`);
    console.log(`   ðŸ’° Deployer Balance: ${Mina.getBalance(deployerAccount).toString()} MINA`);
    console.log(`   ðŸ’° Sender Balance: ${Mina.getBalance(senderAccount).toString()} MINA`);
    console.log(`   ðŸ’° zkApp Balance: ${Mina.getBalance(zkAppAddress).toString()} MINA`);
    
    const beforeVerifyState = zkApp.getContractStats();
    console.log('ðŸ›ï¸ Smart Contract State:');
    console.log(`   ðŸ›¡ï¸ GLEIF Compliant: ${beforeVerifyState.isGLEIFCompliant.toString()}`);
    console.log(`   ðŸ“ˆ Risk Mitigation: ${beforeVerifyState.riskMitigationBase.toString()}`);
    console.log(`   ðŸ”¢ Total Verifications: ${beforeVerifyState.totalVerifications.toString()}`);
    
    try {
        console.log('\nðŸ”„ Executing Smart Contract Verification Transaction...');
        const txn = await Mina.transaction(
            senderAccount,
            async () => {
                await zkApp.verifyGLEIFComplianceWithParams(
                    enhancedData,
                    oracleSignature
                );
            }
        );

        console.log('ðŸ§® Proving verification transaction...');
        await txn.prove();
        console.log('âœï¸ Signing and sending verification transaction...');
        await txn.sign([senderKey]).send();
        console.log('âœ… Transaction executed successfully');
        
        // AFTER VERIFICATION STATE
        console.log('\nðŸ“Š AFTER SMART CONTRACT VERIFICATION:');
        console.log('ðŸŒ Blockchain State:');
        const afterVerifyBlockchainHeight = Mina.getNetworkState().blockchainLength;
        console.log(`   ðŸ“ Blockchain Height: ${afterVerifyBlockchainHeight.toString()}`);
        console.log(`   ðŸ’° Deployer Balance: ${Mina.getBalance(deployerAccount).toString()} MINA`);
        console.log(`   ðŸ’° Sender Balance: ${Mina.getBalance(senderAccount).toString()} MINA`);
        console.log(`   ðŸ’° zkApp Balance: ${Mina.getBalance(zkAppAddress).toString()} MINA`);
        
        const afterVerifyState = zkApp.getContractStats();
        console.log('ðŸ›ï¸ Smart Contract State:');
        console.log(`   ðŸ›¡ï¸ GLEIF Compliant: ${afterVerifyState.isGLEIFCompliant.toString()}`);
        console.log(`   ðŸ“ˆ Risk Mitigation: ${afterVerifyState.riskMitigationBase.toString()}`);
        console.log(`   ðŸ”¢ Total Verifications: ${afterVerifyState.totalVerifications.toString()}`);
        
        // State Changes Summary
        console.log('\nðŸ“ˆ Verification Changes:');
        console.log(`   ðŸ“ Blockchain Height: ${beforeVerifyBlockchainHeight.toString()} â†’ ${afterVerifyBlockchainHeight.toString()}`);
        console.log(`   ðŸ”¢ Total Verifications: ${beforeVerifyState.totalVerifications.toString()} â†’ ${afterVerifyState.totalVerifications.toString()}`);
        
    } catch (error: unknown) {
        const err = error as Error;
        console.error('âŒ Error executing transaction:', err.message);
        throw error;
    }

    // =================================== ZK PROOF GENERATION ===================================
    console.log('\nðŸ§® Generating ZK Proof for Enhanced Compliance...');
    
    // Check if we should skip ZK proof generation in FAST mode
    if (usePrecompiled && (process.argv[4]?.toUpperCase() === 'FAST')) {
        console.log('ðŸš€ FAST mode enabled - Skipping ZK proof generation for speed');
        
        const proofData = {
            publicOutput: {
                name: enhancedData.name,
                id: enhancedData.lei,
                isCompliant: enhancedData.isCompliant(),
                complianceScore: enhancedData.complianceScore,
                riskLevel: enhancedData.riskLevel,
                jurisdiction: enhancedData.jurisdiction,
            },
            proof: null,
            technicalDetails: {
                jsonLength: 0,
                proofType: 'GLEIFEnhancedProof',
                method: 'proveCompliance',
                verified: false,
                error: 'Skipped in FAST mode'
            }
        };
        
        // Skip to results
        console.log('\nðŸ“Š Enhanced Verification Results:');
        console.log('='.repeat(50));
        console.log(`ðŸ¢ Company: ${enhancedData.name.toString()}`);
        console.log(`ðŸ†” LEI: ${enhancedData.lei.toString()}`);
        console.log(`âœ… Entity Status: ${enhancedData.entity_status.toString()}`);
        console.log(`ðŸ“ Registration Status: ${enhancedData.registration_status.toString()}`);
        console.log(`ðŸ“Š Compliance Score: ${enhancedData.complianceScore.toString()}`);
        console.log(`âš¡ Risk Level: ${enhancedData.riskLevel.toString()}`);
        console.log(`ðŸŒ Jurisdiction: ${enhancedData.jurisdiction.toString()}`);
        console.log(`ðŸ” Oracle Signature: VERIFIED`);
        console.log(`ðŸ§® ZK Proof: SKIPPED (FAST MODE)`);
        
        // Final System State Summary
        console.log('\nðŸ“Š FINAL SYSTEM STATE SUMMARY:');
        console.log('='.repeat(50));
        const finalSystemState = zkApp.getContractStats();
        const finalBlockchainHeight = Mina.getNetworkState().blockchainLength;
        console.log(`ðŸ“ Final Blockchain Height: ${finalBlockchainHeight.toString()}`);
        console.log(`ðŸ›¡ï¸ Final GLEIF Compliant Status: ${finalSystemState.isGLEIFCompliant.toString()}`);
        console.log(`ðŸ“ˆ Final Risk Mitigation: ${finalSystemState.riskMitigationBase.toString()}`);
        console.log(`ðŸ”¢ Total Verifications Completed: ${finalSystemState.totalVerifications.toString()}`);
        console.log(`ðŸ’° Final zkApp Balance: ${Mina.getBalance(zkAppAddress).toString()} MINA`);
        console.log(`ðŸ’° Final Deployer Balance: ${Mina.getBalance(deployerAccount).toString()} MINA`);
        console.log(`ðŸ’° Final Sender Balance: ${Mina.getBalance(senderAccount).toString()} MINA`);
        
        return proofData;
    }
    
    // Check if we should try to use precompiled ZK artifacts
    if (usePrecompiled && (process.argv[4]?.toUpperCase() === 'PRECOMPILED')) {
        console.log('ðŸš€ PRECOMPILED mode enabled - Checking for precompiled ZK artifacts');
        
        // Check for precompiled verification key and prover cache
        try {
            console.log('ðŸ” Checking for precompiled verification key...');
            
            // Try to access the verification key without compilation
            // This would work if the program was previously compiled and cached
            const hasPrecompiledKey = GLEIFEnhancedZKProgram._verificationKey !== undefined;
            
            if (hasPrecompiledKey) {
                console.log('âœ… Found precompiled verification key!');
                console.log('ðŸ” Attempting proof generation with cached provers...');
            } else {
                console.log('âš ï¸ No precompiled verification key found');
                throw new Error('No precompiled ZK artifacts available');
            }
            
            // Attempt to generate proof without explicit compilation (uses cached provers if available)
            const proof = await GLEIFEnhancedZKProgram.proveCompliance(
                Field(0), // gleifToProve
                enhancedData,
                oracleSignature,
                UInt64.from(Date.now()), // currentTimestamp
                Field(70), // complianceThreshold
                Field(3)   // riskThreshold
            );
            
            console.log('âœ… ZK Proof generated using precompiled artifacts!');
            
            // DETAILED PROOF INFORMATION
            console.log('\nðŸ” DETAILED ZK PROOF INFORMATION (PRECOMPILED):');
            console.log('ðŸ“œ Proof Public Output:');
            console.log(`   ðŸ¢ Company: ${proof.publicOutput.name.toString()}`);
            console.log(`   ðŸ†” ID: ${proof.publicOutput.id.toString()}`);
            console.log(`   âœ… Is Compliant: ${proof.publicOutput.isCompliant.toString()}`);
            console.log(`   ðŸ“Š Compliance Score: ${proof.publicOutput.complianceScore.toString()}`);
            console.log(`   âš¡ Risk Level: ${proof.publicOutput.riskLevel.toString()}`);
            console.log(`   ðŸŒ Jurisdiction: ${proof.publicOutput.jurisdiction.toString()}`);
            
            console.log('\nðŸ” Proof Technical Details:');
            console.log(`   ðŸ“œ Proof JSON Length: ${JSON.stringify(proof).length} characters`);
            console.log(`   ðŸ—º Proof Type: GLEIFEnhancedProof`);
            console.log(`   âš™ï¸ Proof Method: proveCompliance`);
            console.log(`   ðŸ” Proof Verification: PASSED (PRECOMPILED ARTIFACTS)`);
            console.log(`   ðŸš€ Compilation Time: SKIPPED - Used cached artifacts`);
            
            const proofData = {
                publicOutput: {
                    name: proof.publicOutput.name,
                    id: proof.publicOutput.id,
                    isCompliant: proof.publicOutput.isCompliant,
                    complianceScore: proof.publicOutput.complianceScore,
                    riskLevel: proof.publicOutput.riskLevel,
                    jurisdiction: proof.publicOutput.jurisdiction,
                },
                proof: proof,
                technicalDetails: {
                    jsonLength: JSON.stringify(proof).length,
                    proofType: 'GLEIFEnhancedProof',
                    method: 'proveCompliance',
                    verified: true,
                    usedPrecompiled: true,
                    smartContractVerified: false as boolean,
                    verificationError: undefined as string | undefined
                }
            };
            
            // Continue to smart contract proof verification
            console.log('\nðŸ” Verifying ZK Proof on Smart Contract (PRECOMPILED)...');
            try {
                console.log('ðŸ”„ Executing Proof-Based Transaction with precompiled proof...');
                const proofTxn = await Mina.transaction(senderAccount, async () => {
                    await zkApp.verifyGLEIFComplianceWithZKProof(proof);
                });
                console.log('ðŸ§® Proving proof-based transaction...');
                await proofTxn.prove();
                console.log('âœï¸ Signing and sending proof-based transaction...');
                await proofTxn.sign([senderKey]).send();
                console.log('âœ… Proof-based verification successful (PRECOMPILED)!');
                
                // Update technical details
                proofData.technicalDetails.smartContractVerified = true;
                
            } catch (proofVerifyError: unknown) {
                const proofErr = proofVerifyError as Error;
                console.error('âŒ Proof-based verification failed:', proofErr.message);
                proofData.technicalDetails.smartContractVerified = false;
                proofData.technicalDetails.verificationError = proofErr.message;
            }
            
            // Skip to results with successful precompiled proof
            console.log('\nðŸ“Š Enhanced Verification Results:');
            console.log('='.repeat(50));
            console.log(`ðŸ¢ Company: ${enhancedData.name.toString()}`);
            console.log(`ðŸ†” LEI: ${enhancedData.lei.toString()}`);
            console.log(`âœ… Entity Status: ${enhancedData.entity_status.toString()}`);
            console.log(`ðŸ“ Registration Status: ${enhancedData.registration_status.toString()}`);
            console.log(`ðŸ“Š Compliance Score: ${enhancedData.complianceScore.toString()}`);
            console.log(`âš¡ Risk Level: ${enhancedData.riskLevel.toString()}`);
            console.log(`ðŸŒ Jurisdiction: ${enhancedData.jurisdiction.toString()}`);
            console.log(`ðŸ” Oracle Signature: VERIFIED`);
            console.log(`ðŸ§® ZK Proof: GENERATED WITH PRECOMPILED ARTIFACTS`);
            console.log(`ðŸ” Smart Contract Verification: ${proofData.technicalDetails.smartContractVerified ? 'PASSED' : 'FAILED'}`);
            
            // Final System State Summary
            console.log('\nðŸ“Š FINAL SYSTEM STATE SUMMARY:');
            console.log('='.repeat(50));
            const finalSystemState = zkApp.getContractStats();
            const finalBlockchainHeight = Mina.getNetworkState().blockchainLength;
            console.log(`ðŸ“ Final Blockchain Height: ${finalBlockchainHeight.toString()}`);
            console.log(`ðŸ›¡ï¸ Final GLEIF Compliant Status: ${finalSystemState.isGLEIFCompliant.toString()}`);
            console.log(`ðŸ“ˆ Final Risk Mitigation: ${finalSystemState.riskMitigationBase.toString()}`);
            console.log(`ðŸ”¢ Total Verifications Completed: ${finalSystemState.totalVerifications.toString()}`);
            console.log(`ðŸ’° Final zkApp Balance: ${Mina.getBalance(zkAppAddress).toString()} MINA`);
            console.log(`ðŸ’° Final Deployer Balance: ${Mina.getBalance(deployerAccount).toString()} MINA`);
            console.log(`ðŸ’° Final Sender Balance: ${Mina.getBalance(senderAccount).toString()} MINA`);
            
            return proofData;
            
        } catch (precompiledError: unknown) {
            const preErr = precompiledError as Error;
            console.log(`âš ï¸ Precompiled artifacts not available: ${preErr.message}`);
            console.log('ðŸ”„ Falling back to full compilation...');
            // Continue to full compilation below
        }
    }
    
    // Compile the ZK Program for proof generation
    console.log('ðŸ› ï¸ Compiling Enhanced ZK Program for proof generation...');
    try {
        await GLEIFEnhancedZKProgram.compile();
        console.log('âœ… ZK Program compiled successfully');
    } catch (compileError: unknown) {
        const compileErr = compileError as Error;
        console.error('âŒ ZK Program compilation failed:', compileErr.message);
        // Set fallback proof data due to compilation failure
        const proofData = {
            publicOutput: {
                name: enhancedData.name,
                id: enhancedData.lei,
                isCompliant: enhancedData.isCompliant(),
                complianceScore: enhancedData.complianceScore,
                riskLevel: enhancedData.riskLevel,
                jurisdiction: enhancedData.jurisdiction,
            },
            proof: null,
            technicalDetails: {
                jsonLength: 0,
                proofType: 'GLEIFEnhancedProof',
                method: 'proveCompliance',
                verified: false,
                error: `Compilation failed: ${compileErr.message}`
            }
        };
        
        // Skip to results with compilation error
        console.log('\nðŸ“Š Enhanced Verification Results:');
        console.log('='.repeat(50));
        console.log(`ðŸ¢ Company: ${enhancedData.name.toString()}`);
        console.log(`ðŸ†” LEI: ${enhancedData.lei.toString()}`);
        console.log(`âœ… Entity Status: ${enhancedData.entity_status.toString()}`);
        console.log(`ðŸ“ Registration Status: ${enhancedData.registration_status.toString()}`);
        console.log(`ðŸ“Š Compliance Score: ${enhancedData.complianceScore.toString()}`);
        console.log(`âš¡ Risk Level: ${enhancedData.riskLevel.toString()}`);
        console.log(`ðŸŒ Jurisdiction: ${enhancedData.jurisdiction.toString()}`);
        console.log(`ðŸ” Oracle Signature: VERIFIED`);
        console.log(`ðŸ§® ZK Proof: COMPILATION FAILED`);
        
        return proofData;
    }
    
    // Define the proof data type
    let proofData: {
        publicOutput: {
            name: CircuitString;
            id: CircuitString;
            isCompliant: Bool;
            complianceScore: Field;
            riskLevel: Field;
            jurisdiction: CircuitString;
        };
        proof: any;
        technicalDetails: {
            jsonLength: number;
            proofType: string;
            method: string;
            verified: boolean;
            error?: string;
        };
    };
    
    try {
        // Generate proof using the enhanced ZK program
        const proof = await GLEIFEnhancedZKProgram.proveCompliance(
            Field(0), // gleifToProve
            enhancedData,
            oracleSignature,
            UInt64.from(Date.now()), // currentTimestamp
            Field(70), // complianceThreshold
            Field(3)   // riskThreshold
        );
        
        console.log('âœ… ZK Proof generated successfully!');
        
        // DETAILED PROOF INFORMATION
        console.log('\nðŸ” DETAILED ZK PROOF INFORMATION:');
        console.log('ðŸ“œ Proof Public Output:');
        console.log(`   ðŸ¢ Company: ${proof.publicOutput.name.toString()}`);
        console.log(`   ðŸ†” ID: ${proof.publicOutput.id.toString()}`);
        console.log(`   âœ… Is Compliant: ${proof.publicOutput.isCompliant.toString()}`);
        console.log(`   ðŸ“Š Compliance Score: ${proof.publicOutput.complianceScore.toString()}`);
        console.log(`   âš¡ Risk Level: ${proof.publicOutput.riskLevel.toString()}`);
        console.log(`   ðŸŒ Jurisdiction: ${proof.publicOutput.jurisdiction.toString()}`);
        
        console.log('\nðŸ” Proof Technical Details:');
        console.log(`   ðŸ“œ Proof JSON Length: ${JSON.stringify(proof).length} characters`);
        console.log(`   ðŸ—º Proof Type: GLEIFEnhancedProof`);
        console.log(`   âš™ï¸ Proof Method: proveCompliance`);
        console.log(`   ðŸ” Proof Verification: PASSED`);
        
        // Set successful proof data
        proofData = {
            publicOutput: {
                name: proof.publicOutput.name,
                id: proof.publicOutput.id,
                isCompliant: proof.publicOutput.isCompliant,
                complianceScore: proof.publicOutput.complianceScore,
                riskLevel: proof.publicOutput.riskLevel,
                jurisdiction: proof.publicOutput.jurisdiction,
            },
            proof: proof,
            technicalDetails: {
                jsonLength: JSON.stringify(proof).length,
                proofType: 'GLEIFEnhancedProof',
                method: 'proveCompliance',
                verified: true
            }
        };
        
    } catch (error: unknown) {
        const err = error as Error;
        console.error('âŒ ZK Proof generation failed:', err.message);
        
        // Set fallback proof data
        proofData = {
            publicOutput: {
                name: enhancedData.name,
                id: enhancedData.lei,
                isCompliant: enhancedData.isCompliant(),
                complianceScore: enhancedData.complianceScore,
                riskLevel: enhancedData.riskLevel,
                jurisdiction: enhancedData.jurisdiction,
            },
            proof: null,
            technicalDetails: {
                jsonLength: 0,
                proofType: 'GLEIFEnhancedProof',
                method: 'proveCompliance',
                verified: false,
                error: err.message
            }
        };
    }

    // =================================== Results ===================================
    console.log('\nðŸ“Š Enhanced Verification Results:');
    console.log('='.repeat(50));
    console.log(`ðŸ›ï¸ Company: ${enhancedData.name.toString()}`);
    console.log(`ðŸ†” LEI: ${enhancedData.lei.toString()}`);
    console.log(`âœ… Entity Status: ${enhancedData.entity_status.toString()}`);
    console.log(`ðŸ“‹ Registration Status: ${enhancedData.registration_status.toString()}`);
    console.log(`ðŸ“Š Compliance Score: ${enhancedData.complianceScore.toString()}`);
    console.log(`âš¡ Risk Level: ${enhancedData.riskLevel.toString()}`);
    console.log(`ðŸŒ Jurisdiction: ${enhancedData.jurisdiction.toString()}`);
    console.log(`ðŸ” Oracle Signature: VERIFIED`);
    console.log(`ðŸ§® ZK Proof: ${proofData.technicalDetails.verified ? 'GENERATED & VERIFIED' : 'FAILED'}`);
    
    // Final System State Summary
    console.log('\nðŸ“Š FINAL SYSTEM STATE SUMMARY:');
    console.log('='.repeat(50));
    const finalSystemState = zkApp.getContractStats();
    const finalBlockchainHeight = Mina.getNetworkState().blockchainLength;
    console.log(`ðŸ“ Final Blockchain Height: ${finalBlockchainHeight.toString()}`);
    console.log(`ðŸ›¡ï¸ Final GLEIF Compliant Status: ${finalSystemState.isGLEIFCompliant.toString()}`);
    console.log(`ðŸ“ˆ Final Risk Mitigation: ${finalSystemState.riskMitigationBase.toString()}`);
    console.log(`ðŸ”¢ Total Verifications Completed: ${finalSystemState.totalVerifications.toString()}`);
    console.log(`ðŸ’° Final zkApp Balance: ${Mina.getBalance(zkAppAddress).toString()} MINA`);
    console.log(`ðŸ’° Final Deployer Balance: ${Mina.getBalance(deployerAccount).toString()} MINA`);
    console.log(`ðŸ’° Final Sender Balance: ${Mina.getBalance(senderAccount).toString()} MINA`);
    
    // Return enhanced proof data
    return proofData;
}

main().catch(err => {
    console.error('ðŸ’¥ Unhandled Error:', err);
    process.exit(1);
});